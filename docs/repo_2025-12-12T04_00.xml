This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.go, **/*.js, **/*.ts, **/*.css, **/*.html, **/*.yaml, **/*.toml, **/*.xml, **/*.bat, **/*.sh, **/*.py, **/*.md
- Files matching these patterns are excluded: node_modules, **/node_modules, **/.venv/**, **/venv/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Long base64 data strings (e.g., data:image/png;base64,...) have been truncated to reduce token count
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
assets/
assets/icon128.png
assets/icon16.png
assets/icon48.png
build.js
content.js
favicon.ico
manifest.json
package.json
popup.html
popup.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="build.js">
#!/usr/bin/env node
// Build script for Chrome Extension
// Minifies and bundles all extension files
const esbuild = require('esbuild');
const fs = require('fs');
const path = require('path');
const distDir = 'dist';
const iconsDir = path.join(distDir, 'assets');
// Clean and create dist directory
if (fs.existsSync(distDir)) {
  fs.rmSync(distDir, { recursive: true });
}
fs.mkdirSync(distDir);
fs.mkdirSync(iconsDir);
// Build content script
esbuild.buildSync({
  entryPoints: ['content.js'],
  bundle: true,
  minify: true,
  outfile: path.join(distDir, 'content.js'),
  target: 'chrome90',
  format: 'iife',
});
// Build popup script
esbuild.buildSync({
  entryPoints: ['popup.js'],
  minify: true,
  outfile: path.join(distDir, 'popup.js'),
  target: 'chrome90',
});
// Minify popup HTML
const popupHtml = fs.readFileSync('popup.html', 'utf8');
const minifiedHtml = popupHtml
  .replace(/\n\s+/g, '') // Remove newlines and indentation
  .replace(/>\s+</g, '><') // Remove whitespace between tags
  .replace(/\s{2,}/g, ' '); // Collapse multiple spaces
fs.writeFileSync(path.join(distDir, 'popup.html'), minifiedHtml);
// Copy manifest and icons
fs.copyFileSync('manifest.json', path.join(distDir, 'manifest.json'));
// Copy icon files
const icons = ['icon16.png', 'icon48.png', 'icon128.png'];
icons.forEach(icon => {
  const src = path.join('assets', icon);
  const dest = path.join(iconsDir, icon);
  if (fs.existsSync(src)) {
    fs.copyFileSync(src, dest);
  }
});
console.log('✓ Build complete!');
console.log(`✓ Content script: ${getFileSize('content.js')} → ${getFileSize(path.join(distDir, 'content.js'))}`);
console.log(`✓ Popup script: ${getFileSize('popup.js')} → ${getFileSize(path.join(distDir, 'popup.js'))}`);
console.log(`✓ Popup HTML: ${getFileSize('popup.html')} → ${getFileSize(path.join(distDir, 'popup.html'))}`);
function getFileSize(filepath) {
  const stats = fs.statSync(filepath);
  const kb = (stats.size / 1024).toFixed(2);
  return `${kb} KB`;
}
</file>

<file path="content.js">
// content.js
(function () {
  'use strict';
  // --- Global State ---
  let canvas, ctx;
  let currentSelection = '';
  let selectionRange = null;
  let isVisible = false;
  let animationId = null;
  let buttons = []; // Computed button objects for hit testing
  let loadedIcons = {}; // Cache for Image objects
  // Animation State
  const animState = {
    toastHover: 0,
    buttonHovers: [],
    opacity: 0,
  };
  // --- Default Configuration ---
  let config = {
    style: {
      bgColor: '#0d1117bb',
      bgOpacity: 0.85, // 0 to 1
      hoverColor: '#ffffff',
      hoverOpacity: 0.15,
      borderRadius: 16,
      buttonSize: 32,
      buttonSpacing: 8,
      padding: 8,
      iconSize: 20
    },
    buttons: [
      { id: 'copy', type: 'action', action: 'copy', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="#ddd" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>' },
      { id: 'google', type: 'link', url: 'https://www.google.com/search?q=%s', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="#ddd" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>' },
      { id: 'paste', type: 'action', action: 'paste', icon: '<svg viewBox="0 0 24 24" fill="none" stroke="#ddd" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>' }
    ]
  };
  // --- Initialization ---
  function init() {
    // Load settings from storage, then start
    chrome.storage.sync.get(['canvasToastConfig'], (result) => {
      if (result.canvasToastConfig) {
        config = result.canvasToastConfig;
      }
      setupCanvas();
      loadIcons();
      attachEvents();
    });
    // Listen for live updates from Popup
    chrome.storage.onChanged.addListener((changes) => {
      if (changes.canvasToastConfig) {
        config = changes.canvasToastConfig.newValue;
        loadIcons(); // Reload icons in case they changed
        if (isVisible) draw(); // Redraw immediately if visible
      }
    });
  }
  function setupCanvas() {
    if (canvas) document.body.removeChild(canvas);
    canvas = document.createElement('canvas');
    Object.assign(canvas.style, {
      position: 'fixed',
      pointerEvents: 'none',
      zIndex: '2147483647',
      display: 'none'
    });
    document.body.appendChild(canvas);
    ctx = canvas.getContext('2d');
  }
  function attachEvents() {
    document.addEventListener('mouseup', handleSelectionChange);
    document.addEventListener('mousedown', handleOutsideClick);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('click', handleClick);
    canvas.addEventListener('mouseleave', () => {
      animState.buttonHovers = animState.buttonHovers.map(() => 0);
    });
  }
  // --- Logic ---
  function loadIcons() {
    loadedIcons = {};
    config.buttons.forEach(btn => {
      const img = new Image();
      // Handle base64 or raw SVG string
      let src = btn.icon;
      if (src.trim().startsWith('<svg')) {
        src = 'data:image/svg+xml;base64,' + btoa(src);
      }
      img.onload = () => { loadedIcons[btn.id] = img; };
      img.src = src;
    });
    // Reset animation state array size
    animState.buttonHovers = new Array(config.buttons.length).fill(0);
  }
  function handleSelectionChange() {
    // Small delay to ensure selection is finalized
    setTimeout(() => {
      const sel = window.getSelection();
      const text = sel.toString().trim();
      if (text.length > 0) {
        currentSelection = text;
        selectionRange = sel.getRangeAt(0); // Store range for Paste
        const rect = selectionRange.getBoundingClientRect();
        showToast(rect);
      } else {
        // Only hide if we aren't clicking the canvas itself
        if (!isVisible) return; 
        // We handle hiding in 'handleOutsideClick' usually
      }
    }, 10);
  }
  function handleOutsideClick(e) {
    if (isVisible && e.target !== canvas) {
      hideToast();
    }
  }
  function showToast(rect) {
    isVisible = true;
    animState.opacity = 0;
    // Calculate dimensions
    const count = config.buttons.length;
    const { padding, buttonSize, buttonSpacing } = config.style;
    const totalWidth = padding * 2 + (buttonSize * count) + (buttonSpacing * (count - 1));
    const totalHeight = padding * 2 + buttonSize;
    const buffer = 20;
    // Resize Canvas
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = (totalWidth + buffer * 2) + 'px';
    canvas.style.height = (totalHeight + buffer * 2) + 'px';
    canvas.width = (totalWidth + buffer * 2) * dpr;
    canvas.height = (totalHeight + buffer * 2) * dpr;
    ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset
    ctx.scale(dpr, dpr);
    // Position Canvas
    const left = rect.left + rect.width / 2 - totalWidth / 2;
    const top = rect.top - totalHeight - 15; // 15px above
    canvas.style.left = (left - buffer) + 'px';
    canvas.style.top = (top - buffer) + 'px';
    canvas.style.display = 'block';
    canvas.style.pointerEvents = 'auto';
    startLoop();
  }
  function hideToast() {
    isVisible = false;
    canvas.style.pointerEvents = 'none';
  }
  // --- Rendering & Animation ---
  function startLoop() {
    if (!animationId) loop();
  }
  function loop() {
    if (!isVisible && Math.abs(animState.opacity) < 0.01) {
      animationId = null;
      canvas.style.display = 'none';
      return;
    }
    draw();
    animationId = requestAnimationFrame(loop);
  }
  function lerp(start, end, t) { return start * (1 - t) + end * t; }
  function draw() {
    const { style, buttons: btnConfig } = config;
    const buffer = 20;
    // Calculate Layout
    const count = btnConfig.length;
    const totalW = style.padding * 2 + (style.buttonSize * count) + (style.buttonSpacing * (count - 1));
    const totalH = style.padding * 2 + style.buttonSize;
    // Physics
    animState.opacity = lerp(animState.opacity, isVisible ? 1 : 0, 0.2);
    const isCanvasHover = canvas.style.cursor === 'pointer';
    animState.toastHover = lerp(animState.toastHover, isCanvasHover ? 1 : 0, 0.2);
    ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);
    ctx.save();
    // Global Opacity
    ctx.globalAlpha = animState.opacity;
    // Center & Scale
    const cx = buffer + totalW / 2;
    const cy = buffer + totalH / 2;
    const scale = 1 + (animState.toastHover * 0.05);
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);
    ctx.translate(-cx, -cy);
    // 1. Background
    ctx.shadowBlur = 10 + (animState.toastHover * 10);
    ctx.shadowColor = 'rgba(0,0,0,0.3)';
    ctx.shadowOffsetY = 2 + (animState.toastHover * 2);
    // Parse Hex to RGBA for background opacity
    const hex = style.bgColor.replace('#', '');
    const r = parseInt(hex.substring(0,2), 16);
    const g = parseInt(hex.substring(2,4), 16);
    const b = parseInt(hex.substring(4,6), 16);
    ctx.fillStyle = `rgba(${r},${g},${b},${style.bgOpacity})`;
    roundRect(ctx, buffer, buffer, totalW, totalH, style.borderRadius);
    ctx.fill();
    // Reset shadow
    ctx.shadowBlur = 0;
    ctx.shadowOffsetY = 0;
    // 2. Buttons
    buttons = []; // Reset hit targets
    let x = buffer + style.padding;
    const y = buffer + style.padding;
    btnConfig.forEach((btn, i) => {
      // Hit box storage
      buttons.push({
        x: x - buffer, // Store relative to canvas 0,0 (excluding buffer for hit test logic)
        y: y - buffer,
        w: style.buttonSize,
        h: style.buttonSize,
        data: btn
      });
      // Hover Animation
      const targetHover = (buttons[i].hover) ? 1 : 0;
      animState.buttonHovers[i] = lerp(animState.buttonHovers[i] || 0, targetHover, 0.2);
      const hoverVal = animState.buttonHovers[i];
      // Draw Button BG (Glassy)
      if (hoverVal > 0.01) {
        ctx.fillStyle = style.hoverColor;
        ctx.globalAlpha = animState.opacity * (style.hoverOpacity || 0.2) * hoverVal; 
        roundRect(ctx, x, y, style.buttonSize, style.buttonSize, style.borderRadius / 2);
        ctx.fill();
        ctx.globalAlpha = animState.opacity; // Restore
      }
      // Draw Icon
      const iconImg = loadedIcons[btn.id];
      if (iconImg) {
        const lift = hoverVal * -2;
        const ix = x + (style.buttonSize - style.iconSize) / 2;
        const iy = y + (style.buttonSize - style.iconSize) / 2 + lift;
        ctx.drawImage(iconImg, ix, iy, style.iconSize, style.iconSize);
      }
      x += style.buttonSize + style.buttonSpacing;
    });
    ctx.restore();
  }
  function handleMouseMove(e) {
    if (!isVisible) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left - 20; // Remove buffer
    const my = e.clientY - rect.top - 20;
    let cursor = 'default';
    buttons.forEach((btn, i) => {
      // Determine if mouse is inside button rect
      const isHover = mx >= btn.x && mx <= btn.x + btn.w && my >= btn.y && my <= btn.y + btn.h;
      // We set the property on the button object in the array for the loop to pick up next frame
      // Note: We need to update the config object-derived state? No, we update the local `buttons` hit array.
      // But the animation loop reads animState based on index.
      // So we just need to flag it.
      // Update the "source of truth" for the next frame's hover calculation
      // Since `buttons` is rebuilt every frame in draw(), we need a persistent way to track hover?
      // Actually, draw() rebuilds the rects, but handleMouseMove runs between draws. 
      // Let's store hover state on the `buttons` array generated in the LAST draw, 
      // but wait... `draw` clears `buttons`.
      // Better approach: We check collision here, set a flag, and `draw` uses that flag.
      // However, `draw` rebuilds `buttons`. 
      // FIX: We will just set a temp property on the persistent `config` or a parallel array?
      // Simplest: Just use `buttons` from the last frame. It's close enough.
      btn.hover = isHover; 
      if (isHover) cursor = 'pointer';
    });
    canvas.style.cursor = cursor;
  }
  async function handleClick(e) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left - 20;
    const my = e.clientY - rect.top - 20;
    const clickedBtn = buttons.find(b => mx >= b.x && mx <= b.x + b.w && my >= b.y && my <= b.y + b.h);
    if (clickedBtn) {
      const { type, url, action } = clickedBtn.data;
      if (type === 'link') {
        const finalUrl = url.replace('%s', encodeURIComponent(currentSelection));
        window.open(finalUrl, '_blank');
      } 
      else if (type === 'action') {
        if (action === 'copy') {
          await navigator.clipboard.writeText(currentSelection);
        }
        else if (action === 'paste') {
          try {
            const text = await navigator.clipboard.readText();
            if (selectionRange) {
                selectionRange.deleteContents();
                selectionRange.insertNode(document.createTextNode(text));
            }
          } catch (err) {
            console.error('Paste failed (permision denied?)', err);
            alert('Please allow Clipboard permissions in extension settings.');
          }
        }
      }
      hideToast();
    }
  }
  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, r); // Use modern canvas API
    ctx.closePath();
  }
  // Start
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</file>

<file path="popup.html">
<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      width: 320px;
      font-family: sans-serif;
      padding: 15px;
      background: #0d1117;
      color: #ccc;
    }
    h2 {
      margin-top: 0;
      font-size: 16px;
      margin-bottom: 15px;
      border-bottom: 1px solid #ddd;
      padding-bottom: 10px;
    }
    .section {
      margin-bottom: 20px;
      background: #0d1117;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .label {
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 5px;
      display: block;
      color: #ccc;
    }
    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    input[type="color"] {
      border: none;
      width: 30px;
      height: 30px;
      cursor: pointer;
    }
    input[type="range"] {
      width: 100px;
      color: #ccc;
      background: #09090a;
      border-radius: 6px;
      font-weight: 650;
    }
    input[type="text"],
    textarea {
      width: 100%;
      box-sizing: border-box;
      padding: 6px;
      font-size: 12px;
      color: #ccc;
      background: #09090a;
      border-radius: 6px;
      font-weight: 650;
    }
    textarea {
      height: 60px;
      font-family: monospace;
      resize: vertical;
      color: #ccc;
      background: #09090a;
      border-radius: 6px;
    }
    button {
      background: #333;
      color: #ddd;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
      font-size: 13px;
      font-weight: 650;
    }
    button:hover {
      background: #555;
    }
    .btn-item {
      border: none;
      padding: 8px;
      margin-bottom: 8px;
      border-radius: 4px;
      background: #0d1117;
    }
    .btn-header {
      display: flex;
      justify-content: space-between;
      font-weight: bold;
      font-size: 12px;
      margin-bottom: 5px;
    }
    .remove-btn {
      color: rgb(172, 90, 90);
      cursor: pointer;
    }
    .secondary-btn {
      background: #0d1117;
      color: #ccc;
      margin-top: 5px;
    }
    .secondary-btn:hover {
      background: #ffffff20;
    }
  </style>
</head>
<body>
  <h2>Butter Your Toast!</h2>
  <!-- Visual Settings -->
  <div class="section">
    <span class="label">Jellies</span>
    <div class="row">
      <span>Toast Color</span>
      <input type="color" id="bgColor">
    </div>
    <div class="row">
      <span>Toastacity</span>
      <input type="range" id="bgOpacity" min="0.1" max="1" step="0.1">
    </div>
    <div class="row">
      <span>Butter Hover Color</span>
      <input type="color" id="hoverColor">
    </div>
  </div>
  <!-- Button List -->
  <div class="section">
    <span class="label">Butters</span>
    <div id="buttonList"></div>
    <button id="addBtn" class="secondary-btn">+More Butter</button>
  </div>
  <button id="save">Save Butter</button>
  <p id="status" style="text-align:center; font-size:11px; color:green; height:15px; margin-top:5px;"></p>
  <script src="popup.js"></script>
</body>
</html>
</file>

<file path="popup.js">
// popup.js
document.addEventListener('DOMContentLoaded', () => {
  const elements = {
    bgColor: document.getElementById('bgColor'),
    bgOpacity: document.getElementById('bgOpacity'),
    hoverColor: document.getElementById('hoverColor'),
    buttonList: document.getElementById('buttonList'),
    addBtn: document.getElementById('addBtn'),
    saveBtn: document.getElementById('save'),
    status: document.getElementById('status')
  };
  // Default structure if nothing exists
  const defaultConfig = {
    style: {
      bgColor: '#121212',
      bgOpacity: 0.9,
      hoverColor: '#ffffff',
      hoverOpacity: 0.15,
      borderRadius: 16,
      buttonSize: 32,
      buttonSpacing: 8,
      padding: 8,
      iconSize: 20
    },
    buttons: [
      { id: 'copy', type: 'action', action: 'copy', icon: '<svg viewBox="0 0 24 24" stroke="#fff" stroke-width="2" fill="none"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>' }
    ]
  };
  let currentConfig = null;
  // Load Settings
  chrome.storage.sync.get(['canvasToastConfig'], (result) => {
    currentConfig = result.canvasToastConfig || defaultConfig;
    renderUI();
  });
  function renderUI() {
    // Styles
    elements.bgColor.value = currentConfig.style.bgColor;
    elements.bgOpacity.value = currentConfig.style.bgOpacity;
    elements.hoverColor.value = currentConfig.style.hoverColor;
    // Buttons
    elements.buttonList.innerHTML = '';
    currentConfig.buttons.forEach((btn, index) => {
      const div = document.createElement('div');
      div.className = 'btn-item';
      div.innerHTML = `
        <div class="btn-header">
          <span>Button ${index + 1}</span>
          <span class="remove-btn" data-index="${index}">✖</span>
        </div>
        <div class="row">
            <select class="type-select" data-index="${index}" style="width:100%">
                <option value="action" ${btn.type === 'action' ? 'selected' : ''}>Built-in Action</option>
                <option value="link" ${btn.type === 'link' ? 'selected' : ''}>Search / Link URL</option>
            </select>
        </div>
        ${btn.type === 'action' ? `
        <div class="row">
            <select class="action-select" data-index="${index}" style="width:100%">
                <option value="copy" ${btn.action === 'copy' ? 'selected' : ''}>Copy</option>
                <option value="paste" ${btn.action === 'paste' ? 'selected' : ''}>Paste</option>
            </select>
        </div>` : `
        <div class="row">
            <input type="text" class="url-input" data-index="${index}" value="${btn.url || ''}" placeholder="https://google.com/search?q=%s">
        </div>
        `}
        <div class="row">
            <span style="font-size:10px">SVG Icon string:</span>
        </div>
        <textarea class="icon-input" data-index="${index}">${btn.icon}</textarea>
      `;
      elements.buttonList.appendChild(div);
    });
    // Attach listeners for dynamic inputs
    document.querySelectorAll('.remove-btn').forEach(el => {
      el.addEventListener('click', (e) => {
        currentConfig.buttons.splice(e.target.dataset.index, 1);
        renderUI();
      });
    });
    document.querySelectorAll('input, select, textarea').forEach(el => {
      el.addEventListener('change', updateConfigFromUI);
    });
  }
  function updateConfigFromUI(e) {
    // Update Style
    currentConfig.style.bgColor = elements.bgColor.value;
    currentConfig.style.bgOpacity = parseFloat(elements.bgOpacity.value);
    currentConfig.style.hoverColor = elements.hoverColor.value;
    // Update specific button if changed
    if(e && e.target.dataset.index !== undefined) {
        const idx = e.target.dataset.index;
        const btn = currentConfig.buttons[idx];
        if (e.target.classList.contains('type-select')) {
            btn.type = e.target.value;
            // Set defaults when switching
            if(btn.type === 'link' && !btn.url) btn.url = 'https://google.com/search?q=%s';
            if(btn.type === 'action' && !btn.action) btn.action = 'copy';
            renderUI(); // Re-render to show correct fields
            return;
        }
        if (e.target.classList.contains('action-select')) btn.action = e.target.value;
        if (e.target.classList.contains('url-input')) btn.url = e.target.value;
        if (e.target.classList.contains('icon-input')) btn.icon = e.target.value;
    }
  }
  elements.addBtn.addEventListener('click', () => {
    currentConfig.buttons.push({
      id: 'custom-' + Date.now(),
      type: 'link',
      url: 'https://',
      icon: '<svg viewBox="0 0 24 24" fill="#fff"><circle cx="12" cy="12" r="10"/></svg>'
    });
    renderUI();
  });
  elements.saveBtn.addEventListener('click', () => {
    // Final scrape of UI values to be safe
    updateConfigFromUI();
    chrome.storage.sync.set({ canvasToastConfig: currentConfig }, () => {
      const status = elements.status;
      status.textContent = 'Options saved.';
      setTimeout(() => { status.textContent = ''; }, 1500);
    });
  });
});
</file>

</files>
