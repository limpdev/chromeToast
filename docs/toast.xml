This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*.json, **/*.js, **/*.css, **/*.html
- Files matching these patterns are excluded: node_modules, **/node_modules, **/.venv/**, **/venv/**, **/yarn.lock, **/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Long base64 data strings (e.g., data:image/png;base64,...) have been truncated to reduce token count
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
assets/
docs/
build.js
content.js
manifest.json
package.json
popup.html
popup.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="build.js">
#!/usr/bin/env node
const esbuild = require('esbuild')
const fs = require('fs')
const path = require('path')
const archiver = require('archiver')
// Config
const distDir = 'dist'
const iconsDir = path.join(distDir, 'assets')
const zipName = 'extension.zip'
console.log('üöß Starting Build Process...')
// 1. Clean Dist
if (fs.existsSync(distDir)) {
  fs.rmSync(distDir, { recursive: true })
}
if (fs.existsSync(zipName)) {
  fs.rmSync(zipName)
}
fs.mkdirSync(distDir)
fs.mkdirSync(iconsDir)
// 2. Bundle Content Script
esbuild.buildSync({
  entryPoints: ['content.js'],
  bundle: true,
  minify: true,
  outfile: path.join(distDir, 'content.js'),
  target: 'chrome100', // Modern chrome target
  format: 'iife'
})
// 3. Bundle Popup
esbuild.buildSync({
  entryPoints: ['popup.js'],
  minify: true,
  outfile: path.join(distDir, 'popup.js'),
  target: 'chrome100'
})
// 4. Minify HTML
const popupHtml = fs.readFileSync('popup.html', 'utf8')
const minifiedHtml = popupHtml
  .replace(/\n\s+/g, '')
  .replace(/>\s+</g, '><')
  .replace(/<!--.*?-->/g, '')
fs.writeFileSync(path.join(distDir, 'popup.html'), minifiedHtml)
// 5. Assets & Manifest
fs.copyFileSync('manifest.json', path.join(distDir, 'manifest.json'))
;['icon16.png', 'icon48.png', 'icon128.png'].forEach(icon => {
  const src = path.join('assets', icon)
  const dest = path.join(iconsDir, icon)
  if (fs.existsSync(src)) {
    fs.copyFileSync(src, dest)
  } else {
    // Create dummy icons if they don't exist to prevent build failure
    if (!fs.existsSync(dest)) {
      fs.writeFileSync(dest, '')
      console.warn(`‚ö†Ô∏è Created empty placeholder for ${icon}`)
    }
  }
})
console.log('‚úÖ Compilation Complete.')
// 6. Zip for Web Store
console.log('üì¶ Packaging for Web Store...')
const output = fs.createWriteStream(zipName)
const archive = archiver('zip', {
  zlib: { level: 9 } // Max compression
})
output.on('close', function () {
  const mb = (archive.pointer() / 1024 / 1024).toFixed(2)
  console.log(`üéâ Success! ${zipName} created (${mb} MB)`)
  console.log(' Ready to upload to Chrome Web Store Dashboard.')
})
archive.on('error', function (err) {
  throw err
})
archive.pipe(output)
archive.directory(distDir, false)
archive.finalize()
</file>

<file path="manifest.json">
{
  "manifest_version": 3,
  "name": "Toast - Floating Selection Menu",
  "version": "2.1.0",
  "description": "A customizable floating action menu that appears when you select text.",
  "permissions": [
    "storage",
    "clipboardRead",
    "clipboardWrite"
  ],
  "content_scripts": [
    {
      "matches": [
        "<all_urls>"
      ],
      "js": [
        "content.js"
      ],
      "run_at": "document_end"
    }
  ],
  "action": {
    "default_popup": "popup.html",
    "default_title": "Toast Settings"
  },
  "icons": {
    "16": "assets/icon16.png",
    "48": "assets/icon48.png",
    "128": "assets/icon128.png"
  },
  "web_accessible_resources": [
    {
      "resources": [
        "assets/*.png"
      ],
      "matches": [
        "<all_urls>"
      ]
    }
  ]
}
</file>

<file path="package.json">
{
  "name": "toast-extension",
  "version": "2.1.0",
  "description": "Customizable floating action menu for text selections.",
  "scripts": {
    "build": "node build.js",
    "watch": "node build.js --watch"
  },
  "dependencies": {
    "esbuild": "^0.20.0"
  },
  "devDependencies": {
    "archiver": "^7.0.0"
  }
}
</file>

<file path="popup.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Toast Settings</title>
  <style>
    :root {
      --bg-color: #0f172a;
      --card-bg: #1e293b;
      --accent: #3b82f6;
      --accent-hover: #2563eb;
      --text: #f1f5f9;
      --text-muted: #94a3b8;
      --border: #334155;
      --danger: #ef4444;
    }
    body {
      width: 360px;
      margin: 0;
      padding: 16px;
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg-color);
      color: var(--text);
    }
    h2 {
      margin: 0 0 16px 0;
      font-size: 18px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    h2 svg {
      width: 20px;
      height: 20px;
      color: var(--accent);
    }
    .section {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
    }
    .section-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
      font-weight: 700;
      margin-bottom: 12px;
      display: block;
      border-bottom: 1px solid var(--border);
      padding-bottom: 4px;
    }
    .control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      font-size: 13px;
    }
    .control-row:last-child {
      margin-bottom: 0;
    }
    .control-col {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
    }
    input[type="color"] {
      -webkit-appearance: none;
      width: 28px;
      height: 28px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: none;
    }
    input[type="range"] {
      width: 100px;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      -webkit-appearance: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      margin-top: -5px;
      /* Alignment fix */
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 4px;
      background: var(--border);
      border-radius: 2px;
    }
    .value-display {
      font-family: monospace;
      font-size: 11px;
      color: var(--text-muted);
      width: 30px;
      text-align: right;
    }
    /* Button List Styling */
    .btn-item {
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 8px;
      transition: border-color 0.2s;
    }
    .btn-item:hover {
      border-color: var(--accent);
    }
    .btn-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 12px;
      font-weight: 600;
    }
    .btn-remove {
      color: var(--text-muted);
      cursor: pointer;
      padding: 2px;
    }
    .btn-remove:hover {
      color: var(--danger);
    }
    input[type="text"],
    textarea,
    select {
      width: 100%;
      box-sizing: border-box;
      background: var(--bg-color);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px;
      border-radius: 4px;
      font-size: 12px;
      margin-bottom: 8px;
    }
    input[type="text"]:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--accent);
    }
    textarea {
      height: 50px;
      font-family: monospace;
      resize: vertical;
    }
    /* Action Buttons */
    .main-btn {
      width: 100%;
      padding: 10px;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      font-size: 13px;
      transition: background 0.2s;
    }
    .btn-primary {
      background: var(--accent);
      color: white;
    }
    .btn-primary:hover {
      background: var(--accent-hover);
    }
    .btn-secondary {
      background: var(--border);
      color: var(--text);
      margin-top: 8px;
    }
    .btn-secondary:hover {
      background: #475569;
    }
    #status {
      text-align: center;
      font-size: 12px;
      margin-top: 10px;
      height: 16px;
      color: #10b981;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .helper-text {
      font-size: 10px;
      color: var(--text-muted);
      margin-bottom: 4px;
      display: block;
    }
    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
  </style>
</head>
<body>
  <h2>
    <svg fill="currentColor" viewBox="0 0 24 24">
      <path d="M19 3H5a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2V5a2 2 0 00-2-2m0 16H5V5h14v14z" />
    </svg>
    Toast Configuration
  </h2>
  <!-- Style Section -->
  <div class="section">
    <span class="section-title">Visual Style</span>
    <div class="control-row">
      <span>Background</span>
      <input type="color" id="bgColor" class="style-input" data-key="bgColor">
    </div>
    <div class="control-row">
      <span>Accent Color</span>
      <input type="color" id="hoverColor" class="style-input" data-key="hoverColor">
    </div>
    <div class="control-row">
      <span>Opacity</span>
      <div style="display:flex; align-items:center; gap:8px;">
        <input type="range" id="bgOpacity" class="style-input" data-key="bgOpacity" min="0.5" max="1" step="0.05">
        <span class="value-display" id="val-bgOpacity">0.95</span>
      </div>
    </div>
  </div>
  <!-- Animation Section (New) -->
  <div class="section">
    <span class="section-title">Animation & Interaction</span>
    <div class="control-row">
      <span>Anim Speed</span>
      <div style="display:flex; align-items:center; gap:8px;">
        <input type="range" id="animSpeed" class="style-input" data-key="animSpeed" min="0.05" max="0.5" step="0.05">
        <span class="value-display" id="val-animSpeed">0.2</span>
      </div>
    </div>
    <div class="control-row">
      <span>Hover Scale</span>
      <div style="display:flex; align-items:center; gap:8px;">
        <input type="range" id="hoverScale" class="style-input" data-key="hoverScale" min="1.0" max="1.5" step="0.05">
        <span class="value-display" id="val-hoverScale">1.15</span>
      </div>
    </div>
    <div class="control-row">
      <span>Active Click</span>
      <div style="display:flex; align-items:center; gap:8px;">
        <input type="range" id="activeScale" class="style-input" data-key="activeScale" min="0.5" max="1.0" step="0.05">
        <span class="value-display" id="val-activeScale">0.95</span>
      </div>
    </div>
    <div class="control-row">
      <span>Icon Lift</span>
      <div style="display:flex; align-items:center; gap:8px;">
        <input type="range" id="iconLift" class="style-input" data-key="iconLift" min="0" max="10" step="1">
        <span class="value-display" id="val-iconLift">3px</span>
      </div>
    </div>
  </div>
  <!-- Actions Section -->
  <div class="section">
    <span class="section-title">Actions & Links</span>
    <div id="buttonList"></div>
    <button id="addBtn" class="main-btn btn-secondary">+ Add Action</button>
  </div>
  <button id="save" class="main-btn btn-primary">Save Changes</button>
  <div id="status">Settings Saved!</div>
  <script src="popup.js"></script>
</body>
</html>
</file>

<file path="popup.js">
// popup.js
document.addEventListener('DOMContentLoaded', () => {
  const elements = {
    buttonList: document.getElementById('buttonList'),
    addBtn: document.getElementById('addBtn'),
    saveBtn: document.getElementById('save'),
    status: document.getElementById('status'),
    styleInputs: document.querySelectorAll('.style-input')
  }
  // --- ENSURED DEFAULT MATCHES CONTENT.JS ---
  const defaultConfig = {
    style: {
      bgColor: '#0f172a',
      bgOpacity: 0.95,
      hoverColor: '#3b82f6',
      hoverOpacity: 0.2,
      borderRadius: 12,
      buttonSize: 36,
      buttonSpacing: 6,
      padding: 6,
      iconSize: 20,
      animSpeed: 0.2,
      hoverScale: 1.15,
      activeScale: 0.95,
      iconLift: 3
    },
    buttons: [
      {
        id: 'copy',
        type: 'action',
        action: 'copy',
        // Filled, reliable SVG icon
        icon: '<svg viewBox="0 0 24 24" fill="#e2e8f0" xmlns="http://www.w3.org/2000/svg"><path d="M16 1H4C2.9 1 2 1.9 2 3V17H4V3H16V1ZM19 5H8C6.9 5 6 5.9 6 7V21C6 22.1 6.9 23 8 23H19C20.1 23 21 22.1 21 21V7C21 5.9 20.1 5 19 5ZM19 21H8V7H19V21Z"/></svg>'
      },
      {
        id: 'google',
        type: 'link',
        url: 'https://www.google.com/search?q=%s',
        icon: '<svg viewBox="0 0 24 24" fill="none" stroke="#e2e8f0" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>'
      }
    ]
  }
  let currentConfig = null
  // Load Settings
  chrome.storage.sync.get(['canvasToastConfig'], result => {
    // Deep Merge Logic
    const saved = result.canvasToastConfig || {}
    currentConfig = {
      style: {
        ...defaultConfig.style,
        ...(saved.style || {})
      },
      // If saved buttons exist and are not empty, use them. Otherwise use default.
      buttons:
        saved.buttons && saved.buttons.length > 0
          ? saved.buttons
          : defaultConfig.buttons
    }
    renderUI()
  })
  function renderUI () {
    // 1. Populate Style Inputs
    elements.styleInputs.forEach(input => {
      const key = input.dataset.key
      if (currentConfig.style[key] !== undefined) {
        input.value = currentConfig.style[key]
        const display = document.getElementById(`val-${key}`)
        if (display) display.textContent = currentConfig.style[key]
      }
    })
    // 2. Populate Buttons
    elements.buttonList.innerHTML = ''
    currentConfig.buttons.forEach((btn, index) => {
      const item = document.createElement('div')
      item.className = 'btn-item'
      let content = `
    <div class="btn-header">
      <span>Action ${index + 1}</span>
      <span class="btn-remove" data-index="${index}">‚úñ</span>
    </div>
    <select class="config-input type-select" data-field="type" data-index="${index}">
      <option value="action" ${
        btn.type === 'action' ? 'selected' : ''
      }>System Action</option>
      <option value="link" ${
        btn.type === 'link' ? 'selected' : ''
      }>Search / Link</option>
    </select>
  `
      if (btn.type === 'action') {
        content += `
      <select class="config-input" data-field="action" data-index="${index}">
        <option value="copy" ${
          btn.action === 'copy' ? 'selected' : ''
        }>Copy Text</option>
        <option value="paste" ${
          btn.action === 'paste' ? 'selected' : ''
        }>Paste Text</option>
      </select>
    `
      } else {
        content += `
      <input type="text" class="config-input" data-field="url" data-index="${index}" 
             value="${
               btn.url || ''
             }" placeholder="https://google.com/search?q=%s">
      <span class="helper-text">Use %s for selected text</span>
    `
      }
      content += `
    <span class="helper-text">SVG Icon Code:</span>
    <textarea class="config-input" data-field="icon" data-index="${index}">${btn.icon}</textarea>
  `
      item.innerHTML = content
      elements.buttonList.appendChild(item)
    })
    attachListeners()
  }
  function attachListeners () {
    // Remove Button
    document.querySelectorAll('.btn-remove').forEach(el => {
      el.addEventListener('click', e => {
        currentConfig.buttons.splice(e.target.dataset.index, 1)
        renderUI()
      })
    })
    // Button Config Inputs
    document.querySelectorAll('.config-input').forEach(el => {
      el.addEventListener('change', e => {
        const idx = e.target.dataset.index
        const field = e.target.dataset.field
        const btn = currentConfig.buttons[idx]
        if (field === 'type') {
          btn.type = e.target.value
          if (btn.type === 'link') {
            btn.url = 'https://google.com/search?q=%s'
            delete btn.action
          }
          if (btn.type === 'action') {
            btn.action = 'copy'
            delete btn.url
          }
          renderUI()
        } else {
          btn[field] = e.target.value
        }
      })
    })
    // Style Inputs
    elements.styleInputs.forEach(input => {
      input.addEventListener('input', e => {
        const key = e.target.dataset.key
        let val = e.target.value
        if (input.type === 'range') {
          val = parseFloat(val)
          const display = document.getElementById(`val-${key}`)
          if (display) display.textContent = val
        }
        currentConfig.style[key] = val
      })
    })
  }
  // Add New Button
  elements.addBtn.addEventListener('click', () => {
    currentConfig.buttons.push({
      id: 'btn-' + Date.now(),
      type: 'link',
      url: 'https://',
      // Consistent default new button icon
      icon: '<svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/></svg>'
    })
    renderUI()
  })
  // Save Settings
  elements.saveBtn.addEventListener('click', () => {
    elements.saveBtn.textContent = 'Saving...'
    chrome.storage.sync.set(
      {
        canvasToastConfig: currentConfig
      },
      () => {
        elements.saveBtn.textContent = 'Save Changes'
        elements.status.style.opacity = '1'
        setTimeout(() => {
          elements.status.style.opacity = '0'
        }, 2000)
      }
    )
  })
})
</file>

<file path="content.js">
// content.js - Refined & Robust
;(function () {
  'use strict'
  // --- Global State ---
  let canvas, ctx
  let currentSelection = ''
  let selectionRange = null
  let isVisible = false
  let animationId = null
  let buttons = []
  let loadedIcons = {}
  let iconsReady = false
  let isMouseDown = false // Track click state for active animation
  // Animation State
  const animState = {
    toastHover: 0,
    buttonHovers: [], // Array of floats (0 to 1)
    buttonActive: [], // Array of floats (0 to 1) for click effect
    opacity: 0,
    hoveredButtonIndex: -1,
    scale: 0.8
  }
  // --- Default Configuration ---
  const defaultConfig = {
    style: {
      bgColor: '#13161D',
      bgOpacity: 0.95,
      hoverColor: '#1B4F80',
      hoverOpacity: 0.2,
      borderRadius: 16,
      buttonSize: 34,
      buttonSpacing: 6,
      padding: 6,
      iconSize: 20,
      animSpeed: 0.3,
      hoverScale: 1.1,
      activeScale: 0.9,
      iconLift: 3
    },
    buttons: [
      {
        id: 'copy',
        type: 'action',
        action: 'copy',
        // High contrast, filled icon for better visibility
        icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><g fill="none" stroke="#d3d3d3" stroke-width="1.5"><path d="M14 7c0-.932 0-1.398-.152-1.765a2 2 0 0 0-1.083-1.083C12.398 4 11.932 4 11 4H8c-1.886 0-2.828 0-3.414.586S4 6.114 4 8v3c0 .932 0 1.398.152 1.765a2 2 0 0 0 1.083 1.083C5.602 14 6.068 14 7 14"/><rect width="10" height="10" x="10" y="10" rx="2"/></g></svg>'
      },
      {
        id: 'google',
        type: 'link',
        url: 'https://www.google.com/search?q=%s',
        icon: '<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80"><g fill="#d3d3d3"><path fill="currentColor" fill-opacity="0.25" d="M63.453 67.749L50.725 55.017a2.998 2.998 0 1 1 4.24-4.24l12.73 12.732a2.998 2.998 0 1 1-4.242 4.24m-47.856-38.68a19.052 19.052 0 1 1 36.806 9.862a19.052 19.052 0 0 1-36.806-9.862"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="m47.445 47.498l3.28 3.28m0 4.239l12.728 12.732a2.998 2.998 0 0 0 4.241-4.24L54.966 50.777a2.998 2.998 0 1 0-4.241 4.24m-30.197-7.545a19.053 19.053 0 1 1 26.944-26.944a19.053 19.053 0 0 1-26.944 26.944" stroke-width="1"/></g></svg>'
      }
    ]
  }
  let config = JSON.parse(JSON.stringify(defaultConfig))
  // --- Initialization ---
  function init () {
    chrome.storage.sync.get(['canvasToastConfig'], result => {
      applyConfig(result.canvasToastConfig)
      setupCanvas()
      loadIcons()
      attachEvents()
    })
    chrome.storage.onChanged.addListener(changes => {
      if (changes.canvasToastConfig) {
        applyConfig(changes.canvasToastConfig.newValue)
        loadIcons()
        if (isVisible) requestAnimationFrame(draw)
      }
    })
  }
  function applyConfig (newConfig) {
    if (!newConfig) return
    // If the saved config has NO buttons (broken state), revert to default buttons
    if (!newConfig.buttons || newConfig.buttons.length === 0) {
      config.buttons = defaultConfig.buttons
    } else {
      config.buttons = newConfig.buttons
    }
    if (newConfig.style) {
      config.style = { ...defaultConfig.style, ...newConfig.style }
    }
  }
  function setupCanvas () {
    if (canvas && document.body.contains(canvas)) {
      document.body.removeChild(canvas)
    }
    canvas = document.createElement('canvas')
    Object.assign(canvas.style, {
      position: 'fixed',
      pointerEvents: 'none',
      zIndex: '2147483647',
      display: 'none',
      filter: 'drop-shadow(0 4px 6px rgba(0,0,0,0.2))'
    })
    document.body.appendChild(canvas)
    ctx = canvas.getContext('2d', { alpha: true })
  }
  function attachEvents () {
    document.addEventListener('mouseup', handleSelectionChange)
    document.addEventListener('mousedown', handleOutsideClick)
    document.addEventListener('scroll', handleScroll, { passive: true })
    canvas.addEventListener('mousemove', handleMouseMove)
    canvas.addEventListener('mousedown', handleCanvasDown)
    canvas.addEventListener('mouseup', handleCanvasUp)
    canvas.addEventListener('mouseleave', () => {
      animState.hoveredButtonIndex = -1
      isMouseDown = false
    })
  }
  // --- Logic ---
  function loadIcons () {
    loadedIcons = {}
    iconsReady = false
    let loadedCount = 0
    const totalIcons = config.buttons.length
    if (totalIcons === 0) {
      iconsReady = true
      return
    }
    animState.buttonHovers = new Array(totalIcons).fill(0)
    animState.buttonActive = new Array(totalIcons).fill(0)
    config.buttons.forEach(btn => {
      const img = new Image()
      let src = btn.icon || ''
      if (src.trim().startsWith('<svg')) {
        try {
          // Explicitly setting charset to utf-8 helps with some SVG parsing issues
          src =
            'data:image/svg+xml;charset=utf-8;base64,' +
            window.btoa(unescape(encodeURIComponent(src)))
        } catch (e) {
          console.error('Icon encoding failed', e)
        }
      }
      img.onload = () => {
        loadedIcons[btn.id] = img
        loadedCount++
        checkReady()
      }
      img.onerror = () => {
        console.warn(`Failed to load icon for ${btn.id}`)
        loadedCount++
        checkReady()
      }
      img.src = src
    })
    function checkReady () {
      if (loadedCount === totalIcons) {
        iconsReady = true
        if (isVisible) requestAnimationFrame(draw)
      }
    }
  }
  function handleSelectionChange (e) {
    if (e.target === canvas) return
    setTimeout(() => {
      const sel = window.getSelection()
      if (sel.rangeCount === 0) return
      const text = sel.toString().trim()
      if (text.length > 0) {
        currentSelection = text
        try {
          selectionRange = sel.getRangeAt(0)
          const rect = selectionRange.getBoundingClientRect()
          if (rect.width === 0 && rect.height === 0) return
          showToast(rect)
        } catch (err) {
          console.error('[Toast] Range error', err)
        }
      } else {
        if (!isMouseDown) hideToast()
      }
    }, 10)
  }
  function handleOutsideClick (e) {
    if (isVisible && e.target !== canvas) {
      hideToast()
    }
  }
  function handleScroll () {
    if (isVisible) hideToast()
  }
  function showToast (rect) {
    const { padding, buttonSize, buttonSpacing } = config.style
    const count = config.buttons.length
    const totalWidth =
      padding * 2 + buttonSize * count + buttonSpacing * (count - 1)
    const totalHeight = padding * 2 + buttonSize
    const buffer = 50
    const dpr = window.devicePixelRatio || 1
    canvas.style.width = totalWidth + buffer * 2 + 'px'
    canvas.style.height = totalHeight + buffer * 2 + 'px'
    canvas.width = (totalWidth + buffer * 2) * dpr
    canvas.height = (totalHeight + buffer * 2) * dpr
    ctx.setTransform(1, 0, 0, 1, 0, 0)
    ctx.scale(dpr, dpr)
    let left = rect.left + rect.width / 2 - totalWidth / 2
    let top = rect.top - totalHeight - 16
    if (top < 0) top = rect.bottom + 16
    if (left < 10) left = 10
    if (left + totalWidth > window.innerWidth - 10) {
      left = window.innerWidth - totalWidth - 10
    }
    canvas.style.left = left - buffer + 'px'
    canvas.style.top = top - buffer + 'px'
    canvas.style.display = 'block'
    canvas.style.pointerEvents = 'auto'
    if (!isVisible) {
      isVisible = true
      animState.opacity = 0
      animState.scale = 0.8
      startLoop()
    }
  }
  function hideToast () {
    isVisible = false
    canvas.style.pointerEvents = 'none'
    animState.hoveredButtonIndex = -1
    isMouseDown = false
  }
  function startLoop () {
    if (!animationId) loop()
  }
  function loop () {
    if (!isVisible && Math.abs(animState.opacity) < 0.01) {
      animationId = null
      canvas.style.display = 'none'
      return
    }
    updateState()
    draw()
    animationId = requestAnimationFrame(loop)
  }
  function lerp (start, end, t) {
    return start * (1 - t) + end * t
  }
  function hexToRgb (hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
    return result
      ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        }
      : { r: 0, g: 0, b: 0 }
  }
  function updateState () {
    const { animSpeed } = config.style
    const speed = animSpeed || 0.2
    const targetOpacity = isVisible ? 1 : 0
    const targetScale = isVisible ? 1 : 0.9
    animState.opacity = lerp(animState.opacity, targetOpacity, speed)
    animState.scale = lerp(animState.scale, targetScale, speed)
    config.buttons.forEach((_, i) => {
      const isHover = animState.hoveredButtonIndex === i
      const hoverTarget = isHover ? 1 : 0
      animState.buttonHovers[i] = lerp(
        animState.buttonHovers[i] || 0,
        hoverTarget,
        speed * 1.5
      )
      const isActive = isHover && isMouseDown
      const activeTarget = isActive ? 1 : 0
      animState.buttonActive[i] = lerp(
        animState.buttonActive[i] || 0,
        activeTarget,
        speed * 2
      )
    })
  }
  function draw () {
    const { style, buttons: btnConfig } = config
    const buffer = 50
    const count = btnConfig.length
    const totalW =
      style.padding * 2 +
      style.buttonSize * count +
      style.buttonSpacing * (count - 1)
    const totalH = style.padding * 2 + style.buttonSize
    const dpr = window.devicePixelRatio || 1
    ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr)
    if (animState.opacity < 0.01) return
    ctx.save()
    const cx = buffer + totalW / 2
    const cy = buffer + totalH / 2
    ctx.translate(cx, cy)
    ctx.scale(animState.scale, animState.scale)
    ctx.translate(-cx, -cy)
    ctx.globalAlpha = animState.opacity
    const bgRgb = hexToRgb(style.bgColor)
    ctx.fillStyle = `rgba(${bgRgb.r},${bgRgb.g},${bgRgb.b},${style.bgOpacity})`
    roundRect(ctx, buffer, buffer, totalW, totalH, style.borderRadius)
    ctx.fill()
    buttons = []
    let x = buffer + style.padding
    const y = buffer + style.padding
    btnConfig.forEach((btn, i) => {
      const hoverVal = animState.buttonHovers[i]
      const activeVal = animState.buttonActive[i]
      const targetScale =
        1 +
        hoverVal * (style.hoverScale - 1) -
        activeVal * (style.hoverScale - style.activeScale)
      const currentBtnSize = style.buttonSize * targetScale
      const offset = (style.buttonSize - currentBtnSize) / 2
      buttons.push({
        x: x,
        y: y,
        w: style.buttonSize,
        h: style.buttonSize,
        data: btn
      })
      const bx = x + offset
      const by = y + offset
      if (hoverVal > 0.01) {
        ctx.fillStyle = style.hoverColor
        ctx.globalAlpha = animState.opacity * style.hoverOpacity * hoverVal
        roundRect(
          ctx,
          bx,
          by,
          currentBtnSize,
          currentBtnSize,
          style.borderRadius /* / 2 */
        )
        ctx.fill()
        ctx.globalAlpha = animState.opacity
      }
      const iconImg = loadedIcons[btn.id]
      if (iconImg && iconsReady) {
        const lift = hoverVal * -1 * (style.iconLift || 0)
        const scaledIconSize = style.iconSize * targetScale
        const ix = x + (style.buttonSize - scaledIconSize) / 2
        const iy = y + (style.buttonSize - scaledIconSize) / 2 + lift
        ctx.filter =
          hoverVal > 0.01 ? `brightness(${1 + hoverVal * 0.3})` : 'none'
        ctx.drawImage(iconImg, ix, iy, scaledIconSize, scaledIconSize)
        ctx.filter = 'none'
      }
      x += style.buttonSize + style.buttonSpacing
    })
    ctx.restore()
  }
  function handleMouseMove (e) {
    if (!isVisible) return
    const rect = canvas.getBoundingClientRect()
    const mx = e.clientX - rect.left
    const my = e.clientY - rect.top
    let cursor = 'default'
    let hoveredIndex = -1
    buttons.forEach((btn, i) => {
      if (
        mx >= btn.x &&
        mx <= btn.x + btn.w &&
        my >= btn.y &&
        my <= btn.y + btn.h
      ) {
        cursor = 'pointer'
        hoveredIndex = i
      }
    })
    animState.hoveredButtonIndex = hoveredIndex
    canvas.style.cursor = cursor
  }
  function handleCanvasDown (e) {
    if (animState.hoveredButtonIndex !== -1) {
      isMouseDown = true
    }
  }
  async function handleCanvasUp (e) {
    isMouseDown = false
    if (animState.hoveredButtonIndex === -1) return
    const btn = buttons[animState.hoveredButtonIndex]
    if (!btn) return
    const { type, url, action } = btn.data
    if (type === 'link') {
      const targetUrl = url.includes('%s')
        ? url.replace('%s', encodeURIComponent(currentSelection))
        : url
      window.open(targetUrl, '_blank')
    } else if (type === 'action') {
      if (action === 'copy') {
        try {
          await navigator.clipboard.writeText(currentSelection)
        } catch (err) {
          console.error('Copy failed:', err)
        }
      } else if (action === 'paste') {
        try {
          const text = await navigator.clipboard.readText()
          if (selectionRange) {
            selectionRange.deleteContents()
            selectionRange.insertNode(document.createTextNode(text))
          }
        } catch (err) {
          console.error(err)
        }
      }
    }
    hideToast()
  }
  function roundRect (ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2
    if (h < 2 * r) r = h / 2
    ctx.beginPath()
    ctx.moveTo(x + r, y)
    ctx.arcTo(x + w, y, x + w, y + h, r)
    ctx.arcTo(x + w, y + h, x, y + h, r)
    ctx.arcTo(x, y + h, x, y, r)
    ctx.arcTo(x, y, x + w, y, r)
    ctx.closePath()
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init)
  } else {
    init()
  }
})()
</file>

</files>
